from typing import List, Dict, Any, Union, Tuple
from enum import Enum

import numpy as np

# Type alias for
#   py::class_<Py_GDYWrapper, std::shared_ptr<Py_GDYWrapper>> gdy(m, "GDY");
#   gdy.def("set_max_steps", &Py_GDYWrapper::setMaxSteps);
#   gdy.def("get_player_count", &Py_GDYWrapper::getPlayerCount);
#   gdy.def("get_action_names", &Py_GDYWrapper::getExternalActionNames);
#   gdy.def("get_action_input_mappings", &Py_GDYWrapper::getActionInputMappings);
#   gdy.def("get_avatar_object", &Py_GDYWrapper::getAvatarObject);
#   gdy.def("create_game", &Py_GDYWrapper::createGame);
#   gdy.def("get_level_count", &Py_GDYWrapper::getLevelCount);
#   gdy.def("get_observer_type", &Py_GDYWrapper::getObserverType);

class GDY:
    def __init__(self): ...
    def set_max_steps(self, max_steps: int): ...
    def get_player_count(self) -> int: ...
    def get_action_names(self) -> List[str]: ...
    def get_action_input_mappings(self) -> Dict[str, Any]: ...
    def get_avatar_object(self) -> str: ...
    def create_game(self, global_observer_name: str) -> GameProcess: ...
    def get_level_count(self) -> int: ...
    def get_observer_type(self, observer_name: str) -> ObserverType: ...

# Type alias for
# py::enum_<ObserverType> observer_type(m, "ObserverType");
#   observer_type.value("NONE", ObserverType::NONE);
#   observer_type.value("VECTOR", ObserverType::VECTOR);
#   observer_type.value("ENTITY", ObserverType::ENTITY);
#   observer_type.value("ASCII", ObserverType::ASCII);
#   observer_type.value("ISOMETRIC", ObserverType::ISOMETRIC);
#   observer_type.value("BLOCK_2D", ObserverType::BLOCK_2D);
#   observer_type.value("SPRITE_2D", ObserverType::SPRITE_2D);

class ObserverType(Enum):
    NONE = 0
    VECTOR = 1
    ENTITY = 2
    ASCII = 3
    ISOMETRIC = 4
    BLOCK_2D = 5
    SPRITE_2D = 6

# Type alias for
# py::class_<Py_GameWrapper, std::shared_ptr<Py_GameWrapper>> game_process(m, "GameProcess");
#   game_process.def("register_player", &Py_GameWrapper::registerPlayer);
#   game_process.def("init", &Py_GameWrapper::init);
#   game_process.def("reset", &Py_GameWrapper::reset);
#   game_process.def("step_parallel", &Py_GameWrapper::stepParallel);
#   game_process.def("load_level", &Py_GameWrapper::loadLevel);
#   game_process.def("load_level_string", &Py_GameWrapper::loadLevelString);
#   game_process.def("get_available_actions", &Py_GameWrapper::getAvailableActionNames);
#   game_process.def("get_available_action_ids", &Py_GameWrapper::getAvailableActionIds);
#   game_process.def("build_valid_action_trees", &Py_GameWrapper::buildValidActionTrees);
#   game_process.def("get_width", &Py_GameWrapper::getWidth);
#   game_process.def("get_height", &Py_GameWrapper::getHeight);
#   game_process.def("get_tile_size", &Py_GameWrapper::getTileSize);
#   game_process.def("get_global_observation_description", &Py_GameWrapper::getGlobalObservationDescription);
#   game_process.def("observe", &Py_GameWrapper::observe);
#   game_process.def("enable_history", &Py_GameWrapper::enableHistory);
#   game_process.def("clone", &Py_GameWrapper::clone);
#   game_process.def("get_state", &Py_GameWrapper::getState);
#   game_process.def("load_state", &Py_GameWrapper::loadState);
#   game_process.def("get_global_variable", &Py_GameWrapper::getGlobalVariables);
#   game_process.def("get_object_names", &Py_GameWrapper::getObjectNames);
#   game_process.def("get_object_variable_names", &Py_GameWrapper::getObjectVariableNames);
#   game_process.def("get_object_variable_map", &Py_GameWrapper::getObjectVariableMap);
#   game_process.def("get_global_variable_names", &Py_GameWrapper::getGlobalVariableNames);
#   game_process.def("get_history", &Py_GameWrapper::getHistory, py::arg("purge")=true);
#   game_process.def("release", &Py_GameWrapper::release);
#   game_process.def("seed", &Py_GameWrapper::seedRandomGenerator);

class GameProcess:
    def __init__(self): ...
    def register_player(self, player_name: str, observer_name: str): ...
    def init(self, is_clone: bool): ...
    def reset(self): ...
    def step_parallel(self, actions: List[List[int]]): ...
    def load_level(self, level: int): ...
    def load_level_string(self, level_string: str): ...
    def get_available_actions(self) -> List[str]: ...
    def get_available_action_ids(self) -> List[int]: ...
    def build_valid_action_trees(self): ...
    def get_width(self) -> int: ...
    def get_height(self) -> int: ...
    def get_tile_size(self) -> int: ...
    def get_global_observation_description(self): ...
    def observe(self, player_id: int): ...
    def enable_history(self): ...
    def clone(self): ...
    def get_state(self): ...
    def load_state(self, state): ...
    def get_global_variable(self, variable_name: str): ...
    def get_object_names(self) -> List[str]: ...
    def get_object_variable_names(self) -> List[str]: ...
    def get_object_variable_map(self): ...
    def get_global_variable_names(self) -> List[str]: ...
    def get_history(self, purge: bool = True): ...
    def release(self): ...
    def seed(self, seed: int): ...

# py::class_<Py_StepPlayerWrapper, std::shared_ptr<Py_StepPlayerWrapper>> player(m, "Player");
#   player.def("step", &Py_StepPlayerWrapper::stepSingle);
#   player.def("step_multi", &Py_StepPlayerWrapper::stepMulti);
#   player.def("observe", &Py_StepPlayerWrapper::observe);
#   player.def("get_observation_description", &Py_StepPlayerWrapper::getObservationDescription);

class Player:
    def __init__(self): ...
    def step(
        self,
        action: Union[List[int], List[List[int]], np.ndarray],
        update_ticks: bool = True,
    ) -> List[int]: ...
    def step_multi(
        self, actions: Union[List[int], List[List[int]], np.ndarray]
    ) -> Tuple[int, bool, bool, Dict]: ...
    def observe(self) -> List[int]: ...
    def get_observation_description(self) -> Dict[str, Any]: ...
